¬°Claro\! Empecemos de nuevo con una soluci√≥n completa y robusta. A continuaci√≥n, te proporciono todos los componentes de c√≥digo necesarios para una Web API de .NET 8 que realiza operaciones CRUD en tu tabla `role_types` utilizando un patr√≥n de repositorio y la librer√≠a Dapper.

He asumido que seguir√°s la estructura de tu proyecto anterior, que utiliza las carpetas **Models**, **Repositories**, y **Controllers**.

-----

### 1\. `Models/RoleType.cs`

Este archivo define la entidad C\# que mapea directamente a las columnas de tu tabla `role_types`. La propiedad `PermissionsJson` se usa para manejar el tipo de datos `JSONB`.

```csharp
using System.Text.Json;

namespace RoleTypesApi.Models
{
    public class RoleType
    {
        public int Id { get; set; }
        public string RoleName { get; set; } = string.Empty;
        public string? Description { get; set; }
        public JsonDocument? PermissionsJson { get; set; }
        public bool IsSystemRole { get; set; }
        public DateTime CreatedAt { get; set; }
        public DateTime UpdatedAt { get; set; }
    }
}
```

-----

### 2\. `Repositories/IRoleTypeRepository.cs`

Este es el contrato para tu repositorio. La interfaz define las operaciones que se pueden realizar, lo que promueve el principio de Inversi√≥n de Dependencias.

```csharp
using RoleTypesApi.Models;

namespace RoleTypesApi.Repositories
{
    public interface IRoleTypeRepository
    {
        Task<IEnumerable<RoleType>> GetAll();
        Task<RoleType?> GetById(int id);
        Task<RoleType> Create(RoleType roleType);
        Task<RoleType?> Update(RoleType roleType);
        Task<bool> Delete(int id);
    }
}
```

-----

### 3\. `Repositories/RoleTypeRepository.cs`

Esta clase implementa la interfaz anterior y contiene la l√≥gica de base de datos utilizando **Dapper**. Las consultas SQL se escriben directamente para obtener el m√°ximo control y rendimiento.

```csharp
using System.Data;
using Dapper;
using Npgsql;
using RoleTypesApi.Models;
using Microsoft.Extensions.Configuration; // Se necesita para inyectar IConfiguration

namespace RoleTypesApi.Repositories
{
    public class RoleTypeRepository : IRoleTypeRepository
    {
        private readonly string _connectionString;

        public RoleTypeRepository(IConfiguration configuration)
        {
            _connectionString = configuration.GetConnectionString("PostgresConnection") ?? throw new InvalidOperationException("Connection string 'PostgresConnection' not found.");
        }

        public async Task<IEnumerable<RoleType>> GetAll()
        {
            using IDbConnection db = new NpgsqlConnection(_connectionString);
            return await db.QueryAsync<RoleType>("SELECT id, role_name, description, permissions_json, is_system_role, created_at, updated_at FROM base_foundation.role_types");
        }

        public async Task<RoleType?> GetById(int id)
        {
            using IDbConnection db = new NpgsqlConnection(_connectionString);
            return await db.QueryFirstOrDefaultAsync<RoleType>("SELECT id, role_name, description, permissions_json, is_system_role, created_at, updated_at FROM base_foundation.role_types WHERE id = @Id", new { Id = id });
        }

        public async Task<RoleType> Create(RoleType roleType)
        {
            var sql = "INSERT INTO base_foundation.role_types (role_name, description, permissions_json, is_system_role) VALUES (@RoleName, @Description, @PermissionsJson, @IsSystemRole) RETURNING id, role_name, description, permissions_json, is_system_role, created_at, updated_at";
            using IDbConnection db = new NpgsqlConnection(_connectionString);
            var newRoleType = await db.QuerySingleAsync<RoleType>(sql, roleType);
            return newRoleType;
        }

        public async Task<RoleType?> Update(RoleType roleType)
        {
            var sql = "UPDATE base_foundation.role_types SET role_name = @RoleName, description = @Description, permissions_json = @PermissionsJson, is_system_role = @IsSystemRole, updated_at = NOW() WHERE id = @Id RETURNING id, role_name, description, permissions_json, is_system_role, created_at, updated_at";
            using IDbConnection db = new NpgsqlConnection(_connectionString);
            var updatedRoleType = await db.QueryFirstOrDefaultAsync<RoleType>(sql, roleType);
            return updatedRoleType;
        }

        public async Task<bool> Delete(int id)
        {
            using IDbConnection db = new NpgsqlConnection(_connectionString);
            var result = await db.ExecuteAsync("DELETE FROM base_foundation.role_types WHERE id = @Id", new { Id = id });
            return result > 0;
        }
    }
}
```

-----

### 4\. `Controllers/RoleTypesController.cs`

El controlador de la API maneja las solicitudes HTTP. Utiliza la interfaz `IRoleTypeRepository` para desacoplar la l√≥gica de negocio de la de acceso a datos.

```csharp
using Microsoft.AspNetCore.Mvc;
using RoleTypesApi.Models;
using RoleTypesApi.Repositories;

namespace RoleTypesApi.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class RoleTypesController : ControllerBase
    {
        private readonly IRoleTypeRepository _repository;

        public RoleTypesController(IRoleTypeRepository repository)
        {
            _repository = repository;
        }

        // GET: api/roletypes
        [HttpGet]
        public async Task<ActionResult<IEnumerable<RoleType>>> GetAll()
        {
            var roleTypes = await _repository.GetAll();
            return Ok(roleTypes);
        }

        // GET: api/roletypes/5
        [HttpGet("{id}")]
        public async Task<ActionResult<RoleType>> GetById(int id)
        {
            var roleType = await _repository.GetById(id);
            if (roleType == null)
            {
                return NotFound();
            }
            return Ok(roleType);
        }

        // POST: api/roletypes
        [HttpPost]
        public async Task<ActionResult<RoleType>> Create(RoleType roleType)
        {
            var newRoleType = await _repository.Create(roleType);
            return CreatedAtAction(nameof(GetById), new { id = newRoleType.Id }, newRoleType);
        }

        // PUT: api/roletypes/5
        [HttpPut("{id}")]
        public async Task<IActionResult> Update(int id, RoleType roleType)
        {
            if (id != roleType.Id)
            {
                return BadRequest("ID mismatch");
            }

            var updatedRoleType = await _repository.Update(roleType);
            if (updatedRoleType == null)
            {
                return NotFound();
            }
            return Ok(updatedRoleType);
        }

        // DELETE: api/roletypes/5
        [HttpDelete("{id}")]
        public async Task<IActionResult> Delete(int id)
        {
            var isDeleted = await _repository.Delete(id);
            if (!isDeleted)
            {
                return NotFound();
            }
            return NoContent();
        }
    }
}
```

-----

### 5\. `Program.cs`

Este es el punto de entrada de tu aplicaci√≥n, donde se configuran los servicios y el pipeline de solicitudes. Aqu√≠ es crucial que registres tu repositorio para la inyecci√≥n de dependencias.

```csharp
// Archivo: Program.cs
// Este archivo es el punto de entrada principal de la aplicaci√≥n.
// Aqu√≠ se configuran los servicios y el middleware.

using Microsoft.OpenApi.Models;
using RoleTypesApi.Repositories;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.

builder.Services.AddControllers();

// h.duque
// Configura la inyecci√≥n de dependencias para tu repositorio
builder.Services.AddScoped<IRoleTypeRepository, RoleTypeRepository>();

// Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen(c =>
{
    c.SwaggerDoc("v1", new OpenApiInfo { Title = "RoleTypes API", Version = "v1" });
});

var app = builder.Build();

// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI(c =>
    {
        c.SwaggerEndpoint("/swagger/v1/swagger.json", "RoleTypes API V1");
        c.RoutePrefix = string.Empty; // Set Swagger UI at app's root
    });
}

app.UseHttpsRedirection();

app.UseAuthorization();

app.MapControllers();

app.Run();
```

-----

### 6\. `appsettings.json`

Este archivo contendr√° la cadena de conexi√≥n a tu base de datos. Debes reemplazar los valores con tus credenciales.

```json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*",
  "ConnectionStrings": {
    "PostgresConnection": "Host=localhost;Database=your_database_name;Username=your_username;Password=your_password"
  }
}
```

-----

### 7\. `launchSettings.json`

Este archivo es opcional pero muy √∫til. Asegura que Visual Studio inicie autom√°ticamente el navegador en la p√°gina de Swagger UI.

```json
{
  "$schema": "http://json.schemastore.org/launchsettings.json",
  "profiles": {
    "http": {
      "commandName": "Project",
      "launchBrowser": true,
      "launchUrl": "swagger",
      "applicationUrl": "http://localhost:5113",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    },
    "https": {
      "commandName": "Project",
      "launchBrowser": true,
      "launchUrl": "swagger",
      "applicationUrl": "https://localhost:7226;http://localhost:5113",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    },
    "IIS Express": {
      "commandName": "IISExpress",
      "launchBrowser": true,
      "launchUrl": "swagger",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    }
  }
}
```


Para instalar las dependencias necesarias de Dapper y el proveedor de PostgreSQL, puedes usar el Administrador de Paquetes de NuGet a trav√©s de la interfaz de Visual Studio o la l√≠nea de comandos.

### Opci√≥n 1: Consola del Administrador de Paquetes (Visual Studio)

1.  En Visual Studio, ve a **Tools** (Herramientas) \> **NuGet Package Manager** (Administrador de Paquetes NuGet) \> **Package Manager Console** (Consola del Administrador de Paquetes).

2.  Aseg√∫rate de que el "Proyecto predeterminado" sea tu proyecto actual (`RoleTypesApi`).

3.  Ejecuta los siguientes comandos uno por uno:

    ```bash
    Install-Package Dapper
    ```

    ```bash
    Install-Package Npgsql
    ```

### Opci√≥n 2: L√≠nea de Comandos (`dotnet CLI`)

1.  Abre un terminal o s√≠mbolo del sistema.

2.  Navega hasta la carpeta de tu proyecto (`RoleTypesApi`).

3.  Ejecuta los siguientes comandos:

    ```bash
    dotnet add package Dapper
    ```

    ```bash
    dotnet add package Npgsql
    ```

Despu√©s de instalar estos paquetes, tu proyecto tendr√° acceso a las librer√≠as necesarias para usar Dapper y conectarse a una base de datos PostgreSQL.


Para ejecutar tu aplicaci√≥n ASP.NET Core desde la l√≠nea de comandos en modo HTTP, usa el siguiente comando del `dotnet CLI`:

```bash
dotnet run --launch-profile http
```

### Explicaci√≥n del comando

  * **`dotnet run`**: Este es el comando principal que compila y ejecuta la aplicaci√≥n.
  * **`--launch-profile http`**: Esta opci√≥n le indica a `dotnet run` que utilice la configuraci√≥n del perfil llamado **`http`** que se encuentra en tu archivo `launchSettings.json`. Al hacerlo, la aplicaci√≥n se iniciar√° en el puerto HTTP especificado en ese perfil, que en tu caso es `http://localhost:5113`.


  El error que obtuviste, `400 Bad Request`, indica que la petici√≥n que enviaste no tiene el formato correcto, lo que caus√≥ un fallo en el **modelo de validaci√≥n** de ASP.NET Core. Hay dos problemas principales en tu petici√≥n.

### 1\. Error de Formato en `permissionsJson`

El mensaje `'r' is invalid after a value` se debe a que el JSON interno de `permissionsJson` no est√° correctamente escapado dentro del JSON principal. En la l√≠nea `  "permissionsJson": "{"reports": {"view": true}, "users": {"read": true}}" `, las comillas dobles internas (`"reports"`, `"view"`, etc.) est√°n terminando prematuramente la cadena.

Para resolver esto, debes **escapar** las comillas dobles internas con una barra invertida (`\`).

**JSON Original (Incorrecto):**

```json
{
  ...
  "permissionsJson": "{"reports": {"view": true}, "users": {"read": true}}",
  ...
}
```

**JSON Correcto (con comillas escapadas):**

```json
{
  ...
  "permissionsJson": "{\"reports\": {\"view\": true}, \"users\": {\"read\": true}}",
  ...
}
```

-----

### 2\. Campo `id` no necesario y error de validaci√≥n `roleType`

La tabla `role_types` usa `SERIAL` para su `id`, lo que significa que la base de datos genera autom√°ticamente este valor al crear un nuevo registro. Al enviar `"id": 0` en una petici√≥n `POST`, puede causar conflictos de validaci√≥n. La soluci√≥n es **eliminar la propiedad `id`** por completo de la petici√≥n `POST`.

El segundo error, `"The roleType field is required."`, es un problema de validaci√≥n del modelo que indica que el cuerpo de la petici√≥n no se est√° enlazando correctamente a tu clase `RoleType`. Esto puede ocurrir si el controlador espera una propiedad llamada `roleType` que contenga el objeto, en lugar de que el objeto mismo sea el cuerpo de la petici√≥n. Sin embargo, tu controlador est√° correctamente definido para recibir el objeto directamente.

Al corregir el problema de formato del JSON, el validador del modelo deber√≠a ser capaz de procesar el objeto `RoleType` completo y resolver este error.

### Soluci√≥n Completa: Petici√≥n `cURL` Corregida

Aqu√≠ tienes la petici√≥n `cURL` corregida. He escapado las comillas dobles y he eliminado la propiedad `"id"` para una petici√≥n `POST` v√°lida.

```bash
curl -X 'POST' \
  'http://localhost:5113/api/RoleTypes' \
  -H 'accept: application/json' \
  -H 'Content-Type: application/json' \
  -d '{
  "roleName": "Viewer",
  "description": "Read-only access to system data, including viewing reports and user profiles. Cannot modify any data.",
  "permissionsJson": "{\"reports\": {\"view\": true}, \"users\": {\"read\": true}}",
  "isSystemRole": true,
  "createdAt": "2025-09-04T23:52:22.598Z",
  "updatedAt": "2025-09-04T23:52:22.598Z"
}'
```

Al enviar esta petici√≥n, el servidor deber√≠a procesarla correctamente y devolver el objeto `RoleType` creado con su `id` asignado por la base de datos.


El error `System.NotSupportedException` indica que **Dapper no sabe c√≥mo manejar el tipo de datos `System.Text.Json.JsonDocument`** al intentar pasarlo como par√°metro a la base de datos.

Este problema ocurre porque Dapper, un micro-ORM, no tiene un mapeo predeterminado para tipos de objetos complejos como `JsonDocument`. Para que funcione, debes pasar la informaci√≥n como un tipo que Dapper y el controlador de PostgreSQL puedan entender, que en este caso es una cadena de texto (string).

### Soluci√≥n üõ†Ô∏è

Para solucionar el error, debes realizar un cambio en tu modelo `RoleType.cs` y en tu repositorio `RoleTypeRepository.cs`.

1.  **Modifica `RoleType.cs`:**

      * Cambia el tipo de la propiedad `PermissionsJson` de `JsonDocument?` a `string?`.
      * De esta manera, el modelo de tu API manejar√° el JSON como una cadena, que es el formato en el que se env√≠a desde la petici√≥n HTTP y el que Dapper puede pasar a la base de datos.

    <!-- end list -->

    ```csharp
    // Archivo: Models/RoleType.cs

    namespace RoleTypesApi.Models
    {
        public class RoleType
        {
            public int Id { get; set; }
            public string RoleName { get; set; } = string.Empty;
            public string? Description { get; set; }
            public string? PermissionsJson { get; set; } // <--- Cambio aqu√≠
            public bool IsSystemRole { get; set; }
            public DateTime CreatedAt { get; set; }
            public DateTime UpdatedAt { get; set; }
        }
    }
    ```

2.  **Modifica `RoleTypeRepository.cs`:**

      * Al cambiar el tipo en el modelo, las operaciones en el repositorio se simplificar√°n. Dapper ahora podr√° mapear autom√°ticamente la propiedad `PermissionsJson` del modelo a un par√°metro SQL de tipo string, el cual el controlador de PostgreSQL (`Npgsql`) convertir√° correctamente al tipo `JSONB` en la base de datos.
      * No necesitas cambiar nada m√°s, ya que Dapper se encargar√° de la conversi√≥n.
      * **Nota**: Los m√©todos `QueryAsync` y `QuerySingleAsync` manejar√°n la conversi√≥n de string a `JsonDocument` en el lado de la lectura (desde la base de datos al modelo). Sin embargo, si obtienes un error de mapeo al leer, podr√≠as necesitar un `TypeHandler` personalizado, pero la mayor√≠a de las veces el controlador de `Npgsql` y Dapper lo gestionan sin problemas.

Al realizar este cambio y ejecutar tu aplicaci√≥n de nuevo, la petici√≥n `POST` deber√≠a funcionar correctamente.

El error `42804: column "permissions_json" is of type jsonb but expression is of type text` es muy claro. Significa que, aunque has cambiado el tipo de la propiedad `PermissionsJson` a `string` en tu modelo, **la base de datos no sabe c√≥mo convertir autom√°ticamente esa cadena de texto en un tipo `JSONB`** para la inserci√≥n.

Para resolver esto, necesitas indicarle expl√≠citamente a PostgreSQL que trate la cadena de texto como un `JSONB`. Esto se logra a√±adiendo un **cast de tipo** directamente en tu consulta SQL.

### Soluci√≥n: Modifica `RoleTypeRepository.cs`

Debes corregir la sintaxis de las consultas SQL en los m√©todos **`Create`** y **`Update`** para que el par√°metro `@PermissionsJson` se convierta a `jsonb`.

```csharp
// Archivo: Repositories/RoleTypeRepository.cs

using System.Data;
using Dapper;
using Npgsql;
using RoleTypesApi.Models;
using Microsoft.Extensions.Configuration; 

namespace RoleTypesApi.Repositories
{
    public class RoleTypeRepository : IRoleTypeRepository
    {
        private readonly string _connectionString;

        public RoleTypeRepository(IConfiguration configuration)
        {
            _connectionString = configuration.GetConnectionString("PostgresConnection") ?? throw new InvalidOperationException("Connection string 'PostgresConnection' not found.");
        }

        public async Task<IEnumerable<RoleType>> GetAll()
        {
            using IDbConnection db = new NpgsqlConnection(_connectionString);
            return await db.QueryAsync<RoleType>("SELECT id, role_name, description, permissions_json, is_system_role, created_at, updated_at FROM base_foundation.role_types");
        }

        public async Task<RoleType?> GetById(int id)
        {
            using IDbConnection db = new NpgsqlConnection(_connectionString);
            return await db.QueryFirstOrDefaultAsync<RoleType>("SELECT id, role_name, description, permissions_json, is_system_role, created_at, updated_at FROM base_foundation.role_types WHERE id = @Id", new { Id = id });
        }

        public async Task<RoleType> Create(RoleType roleType)
        {
            // Se agrega '::jsonb' para convertir el string al tipo jsonb
            var sql = "INSERT INTO base_foundation.role_types (role_name, description, permissions_json, is_system_role) VALUES (@RoleName, @Description, @PermissionsJson::jsonb, @IsSystemRole) RETURNING id, role_name, description, permissions_json, is_system_role, created_at, updated_at";
            using IDbConnection db = new NpgsqlConnection(_connectionString);
            var newRoleType = await db.QuerySingleAsync<RoleType>(sql, roleType);
            return newRoleType;
        }

        public async Task<RoleType?> Update(RoleType roleType)
        {
            // Se agrega '::jsonb' para convertir el string al tipo jsonb
            var sql = "UPDATE base_foundation.role_types SET role_name = @RoleName, description = @Description, permissions_json = @PermissionsJson::jsonb, is_system_role = @IsSystemRole, updated_at = NOW() WHERE id = @Id RETURNING id, role_name, description, permissions_json, is_system_role, created_at, updated_at";
            using IDbConnection db = new NpgsqlConnection(_connectionString);
            var updatedRoleType = await db.QueryFirstOrDefaultAsync<RoleType>(sql, roleType);
            return updatedRoleType;
        }

        public async Task<bool> Delete(int id)
        {
            using IDbConnection db = new NpgsqlConnection(_connectionString);
            var result = await db.ExecuteAsync("DELETE FROM base_foundation.role_types WHERE id = @Id", new { Id = id });
            return result > 0;
        }
    }
}
```

Al agregar el cast `::jsonb`, le est√°s diciendo a la base de datos que el valor que Dapper le est√° pasando como `@PermissionsJson` debe ser tratado como un JSON v√°lido, lo que solucionar√° el error de tipo. No necesitas modificar el modelo `RoleType.cs` ni el controlador.